---
monofont: Fira Code Light
echo: true
code-fold: true
execute:
  echo: true
  warning: false
  code-fold: true
---

# Country / Medium

Read in files and setup libraries.

```{r}
#| label: setup
library("here")
library("fs")
library("DT")
library("glue")
library("janitor")
library("scales")
library("tidyverse")

data_dir <- "data"
file_name <- "medium_country.csv"

medium_country_raw <- 
  read_csv(
    path_join(c(here(), data_dir, file_name)),
    skip = 6
  ) |> 
  clean_names()
```

## Filter on country level

Using the results from the \[Country\](country.qmd#Final selection of countries) analysis - I decided to filter out some of the low volume countries in terms of \# users, transactions and revenue. This should reduce the "noise" a bit and focus on higher volume and impact markets while keeping our insights actionable.

I decided to pick some simple rules for filtering out countries - more than 500 users and transactions and more than 20,000â‚¬ revenue. This leaves 91 countries in the list.

```{r}
#| label: aggregate-to-country-level
by_country <- 
  medium_country_raw |> 
  group_by(country) |> 
  summarise(
    # summable-metrics
    across(
      c(users, new_users, sessions, transactions, revenue),
      sum
    ),
    # take medians for the rates, shares, durations
    across(
      c(bounce_rate, pages_session, avg_session_duration, ecommerce_conversion_rate),
      median
    )
  ) |> 
  ungroup() |> 
  # calculate new columns
  mutate(
    revenue_per_transaction = revenue / transactions,
    new_users_share = new_users / users,
  ) |> 
  arrange(desc(revenue))

# filter only bigger volume countries
by_country <- by_country |> 
  filter(
    (revenue > 20000) & (users > 500) & (transactions > 500)
  )

datatable(
  by_country,
  options = list(fixedColumns = list(leftColumns = 1))
)
```

Rename country-level columns with a suffix.

```{r}
#| label: rename-country-cols
by_country <- 
  by_country |> 
  rename_with(
    ~ ifelse(
      .x == "country",
      .x,
      glue("{.x}_country")
    )
  )
by_country
```

Setup a clean dataframe on country / medium level and compute some additional metrics.

```{r}
#| label: medium-country-clean
medium_country <- 
  # filtering join on top-volume countries
  medium_country_raw |> 
  inner_join(by_country, join_by(country)) |> 
  # re-arrange a bit
  arrange(desc(revenue_country), country, desc(revenue)) |> 
  relocate(country, .before = medium) |> 
  # calculate share of channel within country for main metrics
  mutate(
    revenue_share = revenue / revenue_country,
    users_share = users / users_country,
    new_users_share = new_users / new_users_country,
    sessions_share = sessions / sessions_country,
    transactions_share = sessions / transactions_country
  ) |> 
  # rank channels within country
  group_by(country) |> 
  mutate(
    across(
      c(users, new_users, sessions, transactions, revenue),
      ~ dense_rank(desc(.x)),
      .names = "{col}_channel_within_country_rank"
    )
  ) |> 
  ungroup()

medium_country
```

```{r}
medium_country |> summarise(n_distinct(country))
```

```{r}
medium_country |> 
  group_by(country) |> 
  summarise(n_mediums = n_distinct(medium)) |> 
  ungroup() |> 
  mutate(country = fct_reorder(country, n_mediums)) |> 
  slice_max(order_by = n_mediums, n = 50) |> 
  ggplot(aes(x = n_mediums, y = country)) +
  geom_col()
```

I want to see:

# Countries with stacked bars as revenue/users/transactions, where the bars are filled by the medium contribution to it

::: panel-tabset
## Total Revenue

Stacked bars filled by medium-revenue that add up to total revenue by country

```{r}
medium_country |> 
  semi_join(
    by_country |> slice_max(order_by = revenue_country, n = 15),
    join_by(country)
  ) |> 
  filter(country != "(not set)") |> 
  mutate(
    medium = case_when(
      medium == "(none)"    ~ "unknown",
      medium == "(not set)" ~ "unknown",
      .default = medium
    ),
    medium = fct_lump(medium, n = 6, w = revenue),
    country = fct_reorder(country, revenue, sum)
  ) |>
  ggplot(aes(x = revenue, y = country, fill = medium)) +
  geom_col(position = "stack") + 
  scale_x_continuous(
    labels = comma_format(),
    expand = c(0, 0.3)
  ) +
  # scale_fill_manual(
  #   values = RColorBrewer::brewer.pal(8, "Dark2")[-4]
  #   values = RColorBrewer::brewer.pal(8, "Set1")[-6]
  # ) +
  scale_fill_brewer(palette = "Dark2", direction = 1) +
  theme(
    legend.position = "bottom"
  ) +
  labs(
    y = NULL
  )
```

## Revenue share

```{r}
medium_country |> 
  semi_join(
    by_country |> slice_max(order_by = revenue_country, n = 15),
    join_by(country)
  ) |> 
  filter(country != "(not set)") |> 
  mutate(
    medium = case_when(
      medium == "(none)"    ~ "unknown",
      medium == "(not set)" ~ "unknown",
      .default = medium
    ),
    medium = fct_lump(medium, n = 6, w = revenue_share),
    medium = fct_reorder2(medium, country, revenue_share),
    country = fct_reorder(country, revenue, sum)
  ) |>
  ggplot(aes(x = revenue_share, y = country, fill = medium)) +
  geom_col(position = "stack") + 
  scale_x_continuous(
    labels = percent_format(),
    expand = c(0, 0.01)
  ) +
  # scale_fill_manual(
  #   values = RColorBrewer::brewer.pal(8, "Dark2")[-4]
  #   values = RColorBrewer::brewer.pal(8, "Set1")[-6]
  # ) +
  scale_fill_brewer(palette = "Dark2", direction = 1) +
  theme(
    legend.position = "bottom"
  ) +
  labs(
    y = NULL
  )
```
:::

# TODO: Top channels

Which channels are the most effective at driving traffic to your website ?

## TODO: Percentage of new sessions

How much of your website traffic represents new visitors ?

## TODO: Other vs. Organic Search

How do other channels compare to Organic Search Traffic ?

# TODO: Sessions vs duration

Compare the average amount of time users spend on your website to the number of sessions.

# TODO: Conversion rate

How effective is your website at converting visitors to leads or signups ?
